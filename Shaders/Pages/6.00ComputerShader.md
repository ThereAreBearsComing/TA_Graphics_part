# Computer Shader
## Intro
最初的巫毒显卡只有俩计算单元，顶点单元和片元单元。但后边人们需要更通用的硬件，并且当时两单元计算量不成正比，所以2000年后NV和AMD发布了现在这种通用GPU，适合大量矩阵运算的硬件单元。看硬件参数也会法线，与CPU不同，GPU是由大量小核心组成，所以AI，图形等等大量并行运算时，GPU效率明显高于CPU非常之多。

当代GPU被设计成可以执行大规模的并行操作，这有益于图形应用，因为在渲染管线中，不论是顶点着色器还是像素着色器，它们都可以独立进行。然而对于一些非图形应用也可以受益于GPU并行架构所提供的大量计算能力。比如说我们有个应用可以把两个excel里的N个值相加，如果N很大，那么是不是可以利用GPU来进行这些相加计算，来提升速度。像这样的非图形应用使用GPU的情况，我们称之为 **GPGPU**（General Purpose GPU）编程。

对于GPGPU编程而言，用户通常需要将GPU计算后的结果返回到CPU中。例如前面的例子中，我们要在CPU中读取到GPU计算后值，以便可以将结果写入到新的excel中。这就涉及到将数据从GPU显存（Video Memory）中拷贝到CPU系统内存（System Memory）中的操作，该操作非常之**慢**。但是相比使用GPU来计算所提升的运行速度而言，可以忽略此问题。下图展示了CPU和RAM、GPU和VRAM、CPU和GPU之间的相对内存带宽速度（图中的数字只是说明性的数字，以显示带宽之间的数量级差异），可以发现瓶颈在于CPU和GPU之间的内存传输。

<br>![image](https://github.com/ThereAreBearsComing/aBookOFtechArt/assets/74708198/885d8f67-d707-4f93-8812-ed7f3d6e021a)

要实现GPGPU编程，我们就需要一个方法来访问GPU从而实现数据并行算法，这里就需要使用到Compute Shader（后面简称为CS）。CS属于图形API中的一种可编程着色器，它独立于渲染管线之外，但是可以对GPU资源（存放在显存中）进行读取和写入操作。本质上来说，**CS允许我们访问GPU来实现数据并行算法，而不需要绘制任何东西**。

当然了，CS除了适用于非图形应用的GPGPU编程外，我们也可以用它实现很多图形应用中的效果，例如**剔除**，**模糊**等。由于CS可以直接读写GPU资源，使得我们能够将CS的输出直接绑定到渲染管线上。因此对于图形应用，我们通常使用GPU的计算结果作为渲染管道的输入，因此不需要将结果从GPU传输到CPU。例如我们要实现一个模糊效果，可以先用CS模糊一个Texture，然后模糊后的Texture可以直接作为Fragment Shader的输入。

## Unity中默认的Compute Shader
在Project中右键，即可创建出一个CS文件：
生成的文件属于一种 Asset 文件，并且都是以 **.compute 作为文件后缀**的。我们来看下里面的默认内容：
```
#pragma kernel CSMain

RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
```

