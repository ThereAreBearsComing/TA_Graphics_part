# 渲染提前期优化
渲染提前期，即进渲染管线前的准备阶段，分别为Culling，Simplization，Batching，

桃子工厂比喻：Culling，当桃子成熟后，需要剔除腐烂，未成熟，树枝树叶等，只摘合格的桃子。Simplization，将不同桃子按大小，品质，品种分类装箱。Batching合批，将桃子装载发货，近距离普通货车，大量需求上火车，时间需求上飞机，有的一天一发，有的一周一发，总之保证下游生产一直有货。这些过程都发生在生产之前吗，通常情况下这一过程都为CPU负责，但一些特殊生产，通过特殊定制流水线对桃子做清洗，筛选等，这过程可以理解为做了GPU加速。（Computer Shader？）

## Culling
哪些是需要剔除的内容:
* 广义上讲
  * 看不见的像素、网格和对象
  * 重复的、用不到的资源
  * 不需要、不执行的代码

### Unity中的剔除
* 像素剔除: 摄像机平截头体剔除(硬件支持)、Back-face Culling(硬件支持)、Early-Z(硬件支持)、Pre-Z Pass（针对前向渲染下Early-Z失效时，通过Pre-Z Pass提前获取场景深度，后续根据场景深度外壳进行像素着色计算的剔除，为Unity2021URP下直接提供的新功能）
* 网格剔除:Layer Mask、可见距离剔除、Occlusion
* 灯光剔除:Tile-Based Deferred Rendering(TBDR，Unity2021已经支持)、Forward+（2021也支持，但试验阶段）
* 场景剔除:Additive Scene

* Depth Priming(Pre-Z pass)使用限制
  * 只能用在Forward前向渲染路径中，自定义Shader需要手动添加DepthOnlyPass
  * 场景不复杂，Overdraw不是造成GPU效率的瓶颈手机上Depth Priming与MSAA同时开启带来的额外开销
  * Overdraw带来的开销还要大
  * DrawCall或其他图形API调用的开销比Overdraw带来的开销还要大

* 用户扩展剔除
  * 场景数据结构:Octree、BSP Tree、Portal、Voxelization.SDF等
  * GPU Culling: Hi-Z Pass、Temporal Reprojection CullingCluster、Tile-based Visible Buffer等

## Simplization
### 哪些是需要简化的内容
广义上讲:
* 运行效率较重的资源（耗时较高，占内存较多）
* 低效、不合适功能

### Unity下的简化
* Quality Settings
* 通过烘焙光照简化实时光照
* 通过BoundingBox或替代体碰撞代替Mesh碰撞通过
* Local Volume代替Global Volume（做特效和后效的区分）
* 用多条RayCast代替开销较高的SphereCast、CapsuleCast等
* 纹理文字代替系统文字
* Mesh LOD
* Shader LOD（多平台或低端设备上的兼容性，尤其是一些Shader需要图形API版本支持时）
* HLOD（大世界使用，可查看Unity官方Github）
* 通过Camer Override代替URP管线中的一些通用设置
* 各种OnDemand更新或分级设置接口
* .....

### 用户扩展简化
* 场景简化数据结构
* 第三方LOD方案
* Mesh Impostor
* Animation LOD
* 骨骼LOD
* 2D寻路代替Navigation Mesh扩展类似OnDemand接口

## Batching
哪些内容需要Batching？
* 广义上讲
  * 资源Batching(Mesh、Texture、Shader参数、材质属性)
  * Draw call Batching (Static Batching、Dynamic Batching
  * GPU Instancing(直接渲染、间接染、程序化间接染)
  * Set Pass call Batching.( SRP Batching

### 资源的Batching
* Mesh:
  * Mesh.CombineMesh，合并静态网格对象（弊端为如果网格较大，造成无法剔除和Overdraw，也会增加内存开销），对于动态skinmesh对象，美术往往会使用多个materialID标记多个子材质，可使用贴图通道图区分材质，i.e. 原神魔法图
  * Submeshes->Single Mesh,合并材质与贴图，不同材质通过通道图标记
* Texture:
  * AtlasTexture,通过纹理坐标映射多张贴图
  * TextureArray纹理数组
* shader变量与材质属性
  * Material Property Block (Build In管线)
  * Const buffer (SRP管线)，通过定义不同的Const buffer来控制提交到GPU的频率

### Draw Call Batching
* Static Batching，引擎在构建时自动将临近可合并静态网格合并，并将可合并网格转换至世界空间，再用他们的顶点信息构建一个顶点缓冲和索引缓冲区，然后在对可见网格进行简单的绘制调用
  * 注：无论是CombineMesh还是Static Batching都不是在运行时进行合批的
  * 如果想在运行时合批可通过Untiy提供的StaticBatchingUtility.Combine的方法进行运行时合批，这对运行时动态生成网格的对象十分有效，如动态生成关卡的roguelike游戏，运行时合批则不用勾选building setting的Batching static了
    * ![image](https://github.com/ThereAreBearsComing/aBookOFtechArt/assets/74708198/6f8264a8-01bd-45ee-ab81-b68ba611dd13)
  * Static Batching会在内存中额外生成一份网格，所以典型“时间换空间”
* Dynamic Batching，一般不会使用，只有不少老设备才会启用，防止负优化

### GPU Instancing
* 利用Instancing Buffer的方法传递多个网格实例的位置，朝向，颜色等属性构成的Instancing Buffer到GPU，避免反复传递多个基础网格在世界空间下变换后的各种顶点数据和额外数据，所有实例都引用同一个基础网格，非常适合创建植被，石头等场景重复网格，在Build in和SRP管线都支持，但在SRP下无法与SRP Batcher兼容。需要开启GPU Instancing时要确保材质中Enable GPU Instancing的开启，如果是自定义Shader则还需要定义Instancing Buffer的结构
* 注：如果基础网格顶点过于简单则会导致GPU利用率低而负优化，所以不确定则要反复测试
* Unity中可通过这三个接口自定义绘制Instancing Buffer
* DrawMeshInstanced，使用简单但有数量限制
* DrawMeshInstancedIndirect，查看Unity文档示例代码
* DrawMeshInstancedProcedural
* ![image](https://github.com/ThereAreBearsComing/aBookOFtechArt/assets/74708198/e5977216-cb3e-46ad-ab60-ee7cbb37acb0)

### Set Pass Call Batching
* SRP Batcher
* Const Buffer
  * UnityPerCamera
  * UnityPerFrame
  * UnityPerPass
  * UnityPerDraw
  * UnityPerDrawRare
  * **UnityPerMaterial**（此Buffer需要开发者定义，这类Const Buffer只有在其属性发生变化时，才会提交到GPU上，我们需要将自定义的着色器变量添加到Const Buffer中，不能又在Const Buffer之外定义的其他属性和Uniform变量）

<br>![image](https://github.com/ThereAreBearsComing/aBookOFtechArt/assets/74708198/01ed63a2-05f5-408a-bc05-a0f9ce4dddd5)

### Batching优化顺序
资源Batching > SRP Batching = Static Batching （这两类Batching一般任何情况都可以开启） > GPUInstancing > Dynamic Batching



